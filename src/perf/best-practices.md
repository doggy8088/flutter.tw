---
title: Performance best practices
title: Flutter 應用效能最佳化最佳實踐
short-title: Best practices
short-title: 最佳實踐
description: How to ensure that your Flutter app is performant.
description: 確保 Flutter 應用的效能。
---

{% include docs/performance.md %}

Generally, Flutter applications are performant by default,
so you only need to avoid common pitfalls to get excellent
performance. These best practice recommendations will help you
write the most performant Flutter app possible.

通常來說，Flutter 建構的應用程式在預設情況下都是高效能的。
所以你只需要避開常見的陷阱，不需要使用複雜的分析工具
對細節做最佳化，就可以獲得優異的效能，
這些最佳建議將幫助你編寫效能最佳的 Flutter 應用程式。

{{site.alert.note}}

  If you are writing web apps in Flutter, you might be interested
  in a series of articles, written by the Flutter Material team,
  after they modified the [Flutter Gallery][] app to make it more
  performant on the web:

  如果你在用 Flutter 編寫 Web 應用，你可能會對下面的系列文章感興趣，
  他們由 Flutter Material 團隊撰寫，記錄了對 [Flutter Gallery][] 應用的修改，
  使其在 Web 上的效能更好:

  * [Optimizing performance in Flutter web apps with tree
    shaking and deferred loading][web-perf-1]

    [透過 tree shaking 和延遲載入來最佳化 Flutter Web 應用的效能 
    (Optimizing performance in Flutter web apps with 
    tree shaking and deferred loading)][web-perf-1]

  * [Improving perceived performance with image placeholders,
    precaching, and disabled navigation transitions][web-perf-2]

    [透過使用圖像佔位符、預快取和禁用導航效果來提高效能 
    (Improving perceived performance with image placeholders, 
    precaching, and disabled navigation transitions)][web-perf-2]

  * [Building performant Flutter widgets][web-perf-3]

    [高效建構 Flutter widgets (Building performant Flutter widgets)][web-perf-3]

{{site.alert.end}}

[Flutter Gallery]: {{site.gallery}}
[web-perf-1]: {{site.flutter-medium}}/optimizing-performance-in-flutter-web-apps-with-tree-shaking-and-deferred-loading-535fbe3cd674
[web-perf-2]: {{site.flutter-medium}}/improving-perceived-performance-with-image-placeholders-precaching-and-disabled-navigation-6b3601087a2b
[web-perf-3]: {{site.flutter-medium}}/building-performant-flutter-widgets-3b2558aa08fa

How do you design a Flutter app to most efficiently
render your scenes? In particular, how do you ensure
that the painting code generated by the
framework is as efficient as possible?
Some rendering and layout operations are known
to be slow, but can't always be avoided.
They should be used thoughtfully,
following the guidance below.

如何設計一個能最有效地渲染頁面的 Flutter 應用程式？
特別是如何確保底層框架產生的繪圖程式碼儘可能高效？
你需要經過謹慎地思考之後再使用那些已知效能很低的渲染和佈局操作。
請遵循下面的指導。

## Minimize expensive operations

## 儘量減少消耗資源的操作

Some operations are more expensive than others,
meaning that they consume more resources.
Obviously, you want to only use these operations
when necessary. How you design and implement your
app's UI can have a big impact on how efficiently it runs.

有些操作特別消耗資源。
很顯然，你只想在必要地時候使用這些操作。
在這種情況下，如何設計和實現應用的 UI，對執行效率有很大影響。

### Control build() cost

### 控制 build() 方法的耗時

Here are some things to keep in mind when designing your UI:

以下是在設計你的 UI 時的一些建議：

* Avoid repetitive and costly work in `build()` methods
  since `build()` can be invoked frequently when
  ancestor widgets rebuild.

  避免在 `build()` 方法中進行重複且耗時的工作，
  因為當父 widget 重建時，子 Wdiget 的 `build()` 方法會被頻繁地呼叫。

* Avoid overly large single widgets with a large `build()` function.
  Split them into different widgets based on encapsulation
  but also on how they change:

  避免在一個超長的 `build()` 方法中返回一個過於龐大的 widget。
  把它們分拆成不同的 widget，並進行封裝，另外它們要這樣改變：

  * When `setState()` is called on a `State` object,
    all descendent widgets rebuild. Therefore,
    localize the `setState()` call to the part of
    the subtree whose UI actually needs to change.
    Avoid calling `setState()` high up in the tree
    if the change is contained to a small part of the tree.

    當在 `State` 物件上呼叫 `setState()`時，所有後代 widget 都將重建。
    因此，將 `setState()` 的呼叫轉移到其 UI 實際需要更改的 widget 子樹部分。
    如果改變的部分僅包含在 widget 樹的一小部分中，
    請避免在 widget 樹的更高層級中呼叫 `setState()`。

  * The traversal to rebuild all descendents stops when the
    same instance of the child widget as the previous
    frame is re-encountered. This technique is heavily
    used inside the framework for optimizing
    animations where the animation doesn't affect the child subtree.
    See the [`TransitionBuilder`][] pattern and
    the [source code for `SlideTransition`][],
    which uses this principle to avoid rebuilding its
    descendents when animating.
    ("Same instance" is evaluated using `operator ==`,
    but see the pitfalls section at the end of this page
    for advice on when to avoid overriding `operator ==`.)

    當重新遇到與前一幀相同的子 widget 例項時，將停止遍歷。
    這種技術在框架內部大量使用，用於最佳化動畫不影響子樹的動畫。
    請參閱 [`TransitionBuilder`][] 模式和遵循此原則的 
    [SlideTransition 程式碼][source code for `SlideTransition`]，
    以避免在動畫過程中重建其後代 widget。
    （“相同的例項”是使用 `operator ==` 進行評估的，
    但是請參閱本頁面末尾的陷阱部分，瞭解有關何時避免覆蓋 `operator ==` 的建議。）

  * Use `const` constructors on widgets as much as possible,
    since they allow Flutter to short-circuit most
    of the rebuild work. To be automatically reminded
    to use `const` when possible, enable the
    recommended lints from the [`flutter_lints`][] package.
    For more information, check out the
    [`flutter_lints` migration guide][].

    請儘可能地在 widget 上使用 `const` 建構函式，
    這將讓 Flutter 的 widget 重建時間大幅縮短。
    要自動提醒使用 `const`，請啟用 [`flutter_lints`][] package 中推薦的 lints。
    瞭解更多資訊，請檢視 [`flutter_lints` 遷移指南][`flutter_lints` migration guide].

  * To create reusable pieces of UIs,
    prefer using a [`StatelessWidget`][]
    rather than a function.

    在建構可複用的 UI 程式碼時，
    最好使用 [`StatelessWidget`][] 而不是函式。

For more information, check out:

瞭解更多資訊，請檢視：

* [Performance considerations][],
  part of the [`StatefulWidget`][] API doc

  [`StatefulWidget`][] API 文件中的 [Performance considerations][] 部分。

* [Widgets vs helper methods][],
  a video from the official Flutter YouTube 
  channel that explains why widgets
  (especially widgets with `const` constructors)
  are more performant than functions.

  [Widget 與 helper 方法][Widgets vs helper methods]，
  Flutter 關於為什麼使用 widget 是更好的做法的解析影片。
  （特別是使用 `const` 構造的 widget）

[`flutter_lints`]: {{site.pub-pkg}}/flutter_lints
[`flutter_lints` migration guide]: {{site.url}}/release/breaking-changes/flutter-lints-package#migration-guide
[Performance considerations]: {{site.api}}/flutter/widgets/StatefulWidget-class.html#performance-considerations
[source code for `SlideTransition`]: {{site.repo.flutter}}/blob/master/packages/flutter/lib/src/widgets/transitions.dart#L168
[`StatefulWidget`]: {{site.api}}/flutter/widgets/StatefulWidget-class.html
[`StatelessWidget`]: {{site.api}}/flutter/widgets/StatelessWidget-class.html
[`TransitionBuilder`]: {{site.api}}/flutter/widgets/TransitionBuilder.html
[Widgets vs helper methods]: {{site.youtube-site}}/watch?v=IOyq-eTRhvo

---

### Use saveLayer() thoughtfully

### 謹慎使用 saveLayer()

Some Flutter code uses `saveLayer()`, an expensive operation,
to implement various visual effects in the UI.
Even if your code doesn't explicitly call `saveLayer()`,
other widgets or packages that you use might call it behind the scenes.
Perhaps your app is calling `saveLayer()` more than necessary;
excessive calls to `saveLayer()` can cause jank.

一些 Flutter 程式碼呼叫了效能代價很大的 `saveLayer()` 方法來實現 UI 中的各種視覺效果。
你使用的其他 widget 或者 package 可能會在幕後呼叫它。
也許你的應用程式會大量呼叫 `saveLayer()`；
過多呼叫 `saveLayer()` 會導致卡頓。

#### Why is saveLayer expensive?

#### 為什麼 saveLayer 代價很大？

Calling `saveLayer()` allocates an offscreen buffer
and drawing content into the offscreen buffer might
trigger a render target switch.
The GPU wants to run like a firehose,
and a render target switch forces the GPU
to redirect that stream temporarily and then
direct it back again. On mobile GPUs this is
particularly disruptive to rendering throughput.

呼叫 `saveLayer()` 會開闢一片離屏緩衝區
並將內容繪製到離屏緩衝區可能會觸發渲染目標切換。
GPU 希望直達目標地執行，
但渲染目標迫使 GPU 暫時重新導向到該資料流，然後又直接把它切回來。
這樣會對渲染吞吐量造成特別大的破壞性。

#### When is saveLayer required?

#### 什麼時候需要 saveLayer？

At runtime, if you need to dynamically display various shapes
coming from a server (for example), each with some transparency,
that might (or might not) overlap,
then you pretty much have to use `saveLayer()`.

在執行時，如果你需要動態地顯示各種形狀效果（例如），
每個形狀都有一定地透明度，可能（或可能不）重疊，
那麼你幾乎必須使用 `saveLayer()`。

#### Debugging calls to saveLayer

#### 除錯 saveLayer 的呼叫

How can you tell how often your app calls `saveLayer()`,
either directly or indirectly?
The `saveLayer()` method triggers
an event on the [DevTools timeline][]; learn when
your scene uses `saveLayer` by checking the
`PerformanceOverlayLayer.checkerboardOffscreenLayers`
switch in the [DevTools Performance view][].

你如何才能知道應用程式呼叫 `saveLayer()` 的頻率，直接還是間接呼叫？
`saveLayer()` 方法會觸發 [DevTools timeline][] 上的一個事件；
透過檢查 [DevTools 效能檢視 (DevTools Performance view)][DevTools Performance view]
中的 `PerformanceOverlayLayer.checkerboardOffscreenLayers` 來了解何時在使用 `saveLayer`。

[DevTools timeline]: {{site.url}}/tools/devtools/performance#timeline-events-tab

#### Minimizing calls to saveLayer

#### 儘量減少 saveLayer 的呼叫

Can you avoid calls to `saveLayer`?
It might require rethinking of how you
create your visual effects:

你能避免對 `saveLayer` 的呼叫嗎？
這可能需要你重新思考如何建立視覺效果：

* If the calls are coming from _your_ code, can you
  reduce or eliminate them?
  For example, perhaps your UI overlaps two shapes,
  each having non-zero transparency:

  如果這些呼叫是來自於 **你** 的程式碼，你能減少或消除它們嗎？
  例如，也許你的使用者介面重疊了兩個形狀，每個形狀都有非零的透明度：

  * If they always overlap in the same amount,
    in the same way, with the same transparency,
    you can precalculate what this overlapped,
    semi-transparent object looks like, cache it,
    and use that instead of calling `saveLayer()`. 
    This works with any static shape you can precalculate.

    如果它們總是以相同的數量、相同的方式、相同的透明度進行重疊，
    你就可以預先計算出這個重疊的、半透明物體的樣子，將其快取起來，
    然後用它代替呼叫 `saveLayer()`。
    這適用於任何你可以預先計算的靜態形狀。

  * Can you refactor your painting logic to avoid
    overlaps altogether?

    你可以換一種繪畫形式以完全避免重疊嗎？

{% comment %}
TBD: It would be nice if we could link to an example.
  Kenzie suggested to John and Tao that we add an
  example to perf_diagnosis_demo. Michael indicated
  that he doesn't have a saveLayer demo.
{% endcomment %}

* If the calls are coming from a package that you don't own,
  contact the package owner and ask why
  these calls are necessary. Can they be reduced or
  eliminated? If not, you might need to find another
  package, or write your own.

  如果這些呼叫不是來自你的 package，
  請聯絡 package 的所有者並詢問為什麼需要使用這些呼叫。
  能否減少或消除它們？
  如果不能，你可能需要尋找其他作者的 package，或自己編寫。

{{site.alert.secondary}}

  **Note to package owners:**
  As a best practice, consider providing documentation
  for when `saveLayer` might be necessary for your package,
  how it might be avoided, and when it can't be avoided.

  **package 的所有者請注意:**
  最好的做法是在文件中說明你的 package 什麼時候會用到 `saveLayer`，
  如何避免它，以及什麼時候無法避免。

{{site.alert.end}}

Other widgets that might trigger `saveLayer()`
and are potentially costly:

其他會觸發 `saveLayer()` 的 widget，也有潛在的效能代價：

* [`ShaderMask`][]
* [`ColorFilter`][]
* [`Chip`][]&mdash;might trigger a call to `saveLayer()` if
  `disabledColorAlpha != 0xff`

  [`Chip`][]&mdash;
  當 `disabledColorAlpha != 0xff` 的時候，會呼叫 `saveLayer()`

* [`Text`][]&mdash;might trigger a call to `saveLayer()`
  if there's an `overflowShader`

  [`Text`][]&mdash;
  當有 `overflowShader` 時，會呼叫`saveLayer()`

[`Chip`]: {{site.api}}/flutter/material/Chip-class.html
[`ColorFilter`]: {{site.api}}/flutter/dart-ui/ColorFilter-class.html
[`FadeInImage`]: {{site.api}}/flutter/widgets/FadeInImage-class.html
[`Opacity`]: {{site.api}}/flutter/widgets/Opacity-class.html
[`ShaderMask`]: {{site.api}}/flutter/widgets/ShaderMask-class.html
[`Text`]: {{site.api}}/flutter/widgets/Text-class.html
[Transparent image]: {{site.api}}/flutter/widgets/Opacity-class.html#transparent-image

---

### Minimize use of opacity and clipping

### 儘量減少使用不透明度和裁剪

Opacity is another expensive operation, as is clipping.
Here are some tips you might find to be useful:

不透明度和裁剪都是特別消耗資源的操作。
這裡有一些建議也許對你有幫助：

* Use the [`Opacity`][] widget only when necessary.
  See the [Transparent image][] section in the `Opacity`
  API page for an example of applying opacity directly
  to an image, which is faster than using the `Opacity`
  widget.

  能不用 [`Opacity`][] widget，
  就儘量不要用。有關將透明度直接應用於圖像的範例，
  請檢視 [Transparent image][]，
  這比使用 `Opacity` widget 更快。

* Instead of wrapping simple shapes or text
  in an `Opacity` widget, it's usually faster to
  just draw them with a semitransparent color.
  (Though this only works if there are no overlapping
  bits in the to-be-drawn shape.)

  與其將簡單的形狀或文字包裹在一個 `Opacity` widget 中，
  不如用半透明的顏色來繪製它們會更快。
  （這僅在要畫的形狀中沒有重疊的部分時有效）。

* To implement fading in an image, consider using the
  [`FadeInImage`][] widget, which applies a gradual
  opacity using the GPU's fragment shader.
  For more information, check out the [`Opacity`][] docs.

  要在圖像中實現淡入淡出，請考慮使用 [`FadeInImage`][] widget，
  該 widget 使用 GPU 的片段著色器應用漸變不透明度。
  瞭解更多詳情，請檢視 [`Opacity`][] 文件。

* **Clipping** doesn't call `saveLayer()` (unless
  explicitly requested with `Clip.antiAliasWithSaveLayer`),
  so these operations aren't as expensive as `Opacity`,
  but clipping is still costly, so use with caution.
  By default, clipping is disabled (`Clip.none`),
  so you must explicitly enable it when needed.

  **Clipping** 不會呼叫 `saveLayer()`
  （除非明確使用 `Clip.antiAliasWithSaveLayer`），
  因此這些操作沒有 `Opacity` 那麼耗時，但仍然很耗時，所以請謹慎使用。

* To create a rectangle with rounded corners,
  instead of applying a clipping rectangle,
  consider using the `borderRadius` property offered
  by many of the widget classes.

  要建立帶圓角的矩形，而不是裁剪矩形來達到圓角的效果，
  請考慮使用很多 widget 都提供的 `borderRadius` 屬性。

---

### Implement grids and lists thoughtfully 

### 謹慎使用網格列表和列表

How your grids and lists are implemented
might be causing performance problems for your app.
This section describes an important best
practice when creating grids and lists,
and how to determine whether your app uses
excessive layout passes.

你的網格列表和列表的實現方式可能會給你的應用程式帶來效能問題。
本節介紹了建立網格列表和列表時的一個重要的最佳實現方式，
以及如何確定你的應用程式是否使用了過多的佈局傳遞。

#### Be lazy!

#### 延遲載入！

When building a large grid or list,
use the lazy builder methods, with callbacks.
That ensures that only the visible portion of the
screen is built at startup time.

當建構一個大型網格列表或列表時，
使用帶有回呼(Callback)的懶惰建構器方法。
這可以確保在啟動時只建構螢幕的可見部分。

For more information and examples, check out:

瞭解更多的資訊和範例，請檢視：

* [Working with long lists][] in the [Cookbook][]

  [實用課程 (Cookbook)][Cookbook] 裡的 [長列表的處理][Working with long lists] 文件

* [Creating a `ListView` that loads one page at a time][]
  a community article by AbdulRahman AlHamali

  來自社群的 AbdulRahman AlHamali 撰寫的文章
  [Creating a `ListView` that loads one page at a time][]

* [`Listview.builder`][] API

[Cookbook]: {{site.url}}/cookbook
[Creating a `ListView` that loads one page at a time]: {{site.medium}}/saugo360/flutter-creating-a-listview-that-loads-one-page-at-a-time-c5c91b6fabd3
[`Listview.builder`]: {{site.api}}/flutter/widgets/ListView/ListView.builder.html
[Working with long lists]: {{site.url}}/cookbook/lists/long-lists

#### Avoid intrinsics

#### 避免內部傳遞

For information on how intrinsic passes might be causing
problems with your grids and lists, see the next section.

關於內部傳遞可能導致你的網格列表和列表出現問題的資訊，見下一節。

---

### Minimize layout passes caused by intrinsic operations

### 儘量減少由內部操作引起的佈局傳遞

If you've done much Flutter programming, you are
probably familiar with [how layout and constraints work][]
when creating your UI. You might even have memorized Flutter's
basic layout rule: **Constraints go down. Sizes go up.
Parent sets position.**

如果你經常使用 Flutter 程式設計，
你可能已經熟悉了在建立 UI 時 [佈局和約束是如何工作的][how layout and constraints work]。
你甚至可能已經記住了 Flutter 的基本佈局規則：<br/>
**首先，上層 widget 向下層 widget 傳遞約束條件；**<br/>
**然後，下層 widget 向上層 widget 傳遞大小資訊；**<br/>
**最後，上層 widget 決定下層 widget 的位置。**<br/>

For some widgets, particularly grids and lists,
the layout process can be expensive.
Flutter strives to perform just one layout pass
over the widgets but, sometimes,
a second pass (called an _intrinsic pass_) is needed,
and that can slow performance.

對於一些 widget，特別是網格列表和列表，
佈局過程中效能代價很大。
Flutter 儘可能在 widget 上只執行一次佈局傳遞，
但有時需要再次傳遞（稱為 **內部傳遞**），
這可能會降低效能。

#### What is an intrinsic pass?

#### 什麼是內部傳遞？

An intrinsic pass happens when, for example,
you want all cells to have the size
of the biggest or smallest cell (or some
similar calculation that requires polling all cells).

例如，你想要所有單元格都具有或大或小的效果（或類似需要輪詢所有單元格的計算）時，
就會發生內部傳遞。

For example, consider a large grid of `Card`s.
A grid should have uniformly sized cells,
so the layout code performs a pass,
starting from the root of the grid (in the widget tree),
asking **each** card in the grid (not just the
visible cards) to return
its _intrinsic_ size&mdash;the size
that the widget prefers, assuming no constraints.
With this information,
the framework determines a uniform cell size,
and re-visits all grid cells a second time,
telling each card what size to use. 

例如，考慮一個大型的 `卡片` 網格列表時。
一個網格列表應該有統一大小的單元格，
所以佈局程式碼執行了一次傳遞，
從網格列表的根部開始（在 widget 樹中），
要求網格列表中的 **每個** 卡片（不僅僅是可見的卡片）
來返回 **內部** 尺寸&mdash;假設沒有任何限制，widget 更喜歡這樣的尺寸。
有了這些資訊，底層框架就確定了一個統一的單元格尺寸，
並再次重新存取所有的網格單元，
告訴每個卡片應該使用什麼尺寸。

#### Debugging intrinsic passes

#### 除錯內部傳遞

To determine whether you have excessive intrinsic passes,
enable the **[Track layouts option][]**
in DevTools (disabled by default),
and look at the app's [stack trace][]
to learn how many layout passes were performed.
Once you enable tracking, intrinsic timeline events
are labeled as '$runtimeType intrinsics'.

要確認你是否有過多的內部傳遞，
請在 DevTools 中啟用 **[佈局追蹤 (Track layouts option)][Track layouts option]** （預設情況下是禁用的），
並檢視應用程式的 [堆疊追蹤 (stack trace)][stack trace] 以瞭解執行了多少次佈局傳遞。
一旦你啟用追蹤，內部的時間線事件將被標記為 "$runtimeType intrinsics"。

#### Avoiding intrinsic passes

#### 避免內部傳遞

You have a couple options for avoiding the intrinsic pass:

你有幾個選擇來避免內部傳遞：

* Set the cells to a fixed size up front.

  將單元格設定為固定大小。

* Choose a particular cell to be the
  "anchor" cell&mdash;all cells will be
  sized relative to this cell.
  Write a custom render object that
  positions the child anchor first and then lays
  out the other children around it.

  選擇一個特定的單元格作為 “錨” &mdash;所有單元格的尺寸都將相對於這個單元格。
  編寫一個自訂渲染物件，首先定位子錨點，然後在其周圍佈置其他子單元。

To dive even deeper into how layout works,
check out the [layout and rendering][]
section in the [Flutter architectural overview][].

要更深入地瞭解佈局的工作原理，
請檢視 [Flutter 架構概覽][Flutter architectural overview] 中的 [佈局和渲染][layout and rendering]。

[Flutter architectural overview]: {{site.url}}/resources/architectural-overview
[how layout and constraints work]: {{site.url}}/ui/layout/constraints
[layout and rendering]: {{site.url}}/resources/architectural-overview#layout-and-rendering
[stack trace]: {{site.url}}/tools/devtools/cpu-profiler#flame-chart
[Track layouts option]: {{site.url}}/tools/devtools/performance#track-layouts

---

### Build and display frames in 16ms

### 在 16ms 內渲染完成每一幀

Since there are two separate threads for building
and rendering, you have 16ms for building,
and 16ms for rendering on a 60Hz display.
If latency is a concern,
build and display a frame in 16ms _or less_.
Note that means built in 8ms or less,
and rendered in 8ms or less,
for a total of 16ms or less.

由於建構和渲染有兩個獨立的執行緒，因此建構時間為 16ms，60Hz 顯示器上渲染時間為 16ms。
如果需要考慮延遲，就要在 16ms **或更短** 的時間內建構和顯示幀。
請注意，這意味著建構需要少於 8ms，渲染也需要少於 8ms，總計 16ms 或更短。

If your frames are rendering in well under
16ms total in [profile mode][],
you likely don't have to worry about performance
even if some performance pitfalls apply,
but you should still aim to build and
render a frame as fast as possible. Why?

如果在 [profile 建構][profile mode] 狀態下，
每一幀渲染時間低於 16ms，你可能不必擔心效能問題以及一些效能陷阱，
但仍然應該致力於儘可能快地渲染每一幀。為什麼？

* Lowering the frame render time below 16ms might not make a visual
  difference, but it **improves battery life** and thermal issues.

  將幀渲染時間降低到 16ms 以下可能在視覺上看不出來什麼變化，
  但可以 **延長電池壽命** 以及避免發熱問題。

* It might run fine on your device, but consider performance for the
  lowest device you are targeting.

  可能在你當前測試裝置上執行良好，但請考慮在應用所支援的最低端裝置上的情況。

* As 120fps devices become more widely available,
  you'll want to render frames in under 8ms (total)
  in order to provide the smoothest experience.

  當 120fps 的裝置普及之後，便需要在 8ms 之內完成每一幀的渲染來保證流暢平滑的體驗。

If you are wondering why 60fps leads to a smooth visual experience,
check out the video [Why 60fps?][]

如果你想弄明白為什麼 60fps 會帶來平滑的視覺體驗，
請看影片 [60fps 是啥意思？][Why 60fps?]

[profile mode]: {{site.url}}/testing/build-modes#profile
[Why 60fps?]: https://www.bilibili.com/video/BV1b441157sA/

## Pitfalls

## 陷阱

If you need to tune your app's performance,
or perhaps the UI isn't as smooth as you expect,
the [DevTools Performance view][] can help!

如果你需要改善應用程式的效能，
或者 UI 流暢度沒達到你的預期，
那麼 [DevTools 效能檢視 (DevTools Performance view)][DevTools Performance view] 可以幫到你！

Also, the Flutter plugin for your IDE might
be useful. In the Flutter Performance window,
enable the **Show widget rebuild information** check box.
This feature helps you detect when frames are
being rendered and displayed in more than 16ms.
Where possible,
the plugin provides a link to a relevant tip.

另外，IDE 中 Flutter plugin 也許也能幫到你。
在 Flutter Performance 視窗中，勾選 **Show widget rebuild information** 複選框。 
此功能可幫助你檢測幀的渲染和顯示時間是否超過 16ms。
外掛也會盡可能提供指向相關提示的連結。

The following behaviors might negatively impact
your app's performance.

以下行為可能會對你應用的效能產生負面影響。

* Avoid using the `Opacity` widget,
  and particularly avoid it in an animation.
  Use `AnimatedOpacity` or `FadeInImage` instead.
  For more information, check out
  [Performance considerations for opacity animation][].

  避免使用 `Opacity` widget，尤其是在動畫中避免使用。
  可以使用 `AnimatedOpacity` 或 `FadeInImage` 代替該操作。
  更多資訊，請參閱
  [Performance considerations for opacity animation][]。

* When using an `AnimatedBuilder`,
  avoid putting a subtree in the builder
  function that builds widgets that don't
  depend on the animation. This subtree is
  rebuilt for every tick of the animation.
  Instead, build that part of the subtree
  once and pass it as a child to
  the `AnimatedBuilder`. For more information,
  check out [Performance optimizations][].

  使用 `AnimatedBuilder` 時，請避免在不依賴於動畫的 widget 的構造方法中建構 widget 樹，
  不然，動畫的每次變動都會重建這個 widget 樹，
  應當將這部分子樹作為 child 傳遞給 `AnimatedBuilder`，從而只建構一次。
  更多內容，請參閱 [Performance optimizations][]。

* Avoid clipping in an animation.
  If possible, pre-clip the image before animating it.

  避免在動畫中裁剪，儘可能的在動畫開始之前預先裁剪圖像。

* Avoid using constructors with a concrete `List`
  of children (such as `Column()` or `ListView()`)
  if most of the children are not visible
  on screen to avoid the build cost.
  
* Avoid overriding `operator ==` on `Widget` objects.
  While it might seem like it would help by avoiding unnecessary rebuilds,
  in practice it hurts performance because it results in O(N²) behavior.
  The only exception to this rule is leaf widgets (widgets with no children),
  in the specific case where comparing the properties of the widget
  is likely to be significantly more efficient than rebuilding the widget
  and where the widget will rarely change configuration.
  Even in such cases,
  it is generally preferable to rely on caching the widgets,
  because even one override of `operator ==`
  can result in across-the-board performance degradation
  as the compiler can no longer assume that the call is always static.

  如果大多數 children widget 在螢幕上不可見，
  請避免使用返回具體列表的建構函式
  （例如 `Column()` 或 `ListView()`），以避免建構成本。

* Avoid overriding `operator ==` on `Widget` objects.
  While it may seem like it would help by avoiding unnecessary rebuilds,
  in practice it hurts performance because it results in O(N²) behavior.
  The only exception to this rule is leaf widgets (widgets with no children),
  in the specific case where comparing the properties of the widget
  is likely to be significantly more efficient than rebuilding the widget
  and where the widget will rarely change configuration.
  Even in such cases,
  it is generally preferable to rely on caching the widgets,
  because even one override of `operator ==`
  can result in across-the-board performance degradation
  as the compiler can no longer assume that the call is always static.

  避免在 `Widget` 物件上重寫 `operator ==`。
  雖然這看起來有助於避免不必要的重建，
  但在實踐中，它實際上損害了效能，因為這是 O(N²) 的行為。
  只有 leaf widget（沒有子的 widget） 是個例外，
  在這種特殊的情況下，比較 widget 的屬性可能比重建 widget 更加有效，
  也能更少改變 widget 的配置。
  即使在這種情況下，最好還要快取 widget，
  因為哪怕有一次對 `operator ==` 進行覆蓋也會導致全面性能的下降，
  編譯器也會因此不再認為呼叫總是靜態的。

## Resources

## 參考資料

For more performance info, check out the following resources:

瞭解更多效能資訊，請參閱以下資源：

* [Performance optimizations][] in the AnimatedBuilder API page

  AnimatedBuilder API 頁面的 [Performance optimizations][] 部分；

* [Performance considerations for opacity animation][]
  in the Opacity API page

  Opacity API 頁面的 [Performance considerations for opacity animation][] 部分；

* [Child elements' lifecycle][] and how to load them efficiently,
  in the ListView API page

  ListView API 頁面中 [Child elements' lifecycle][]，以及如何高效載入元素；

* [Performance considerations][] of a `StatefulWidget`

  `StatefulWidget` 的 [Performance considerations][] API 文件。

[Child elements' lifecycle]: {{site.api}}/flutter/widgets/ListView-class.html#child-elements-lifecycle
[`CustomPainter`]: {{site.api}}/flutter/rendering/CustomPainter-class.html
[DevTools Performance view]: {{site.url}}/tools/devtools/performance
[Performance optimizations]: {{site.api}}/flutter/widgets/AnimatedBuilder-class.html#performance-optimizations
[Performance considerations for opacity animation]: {{site.api}}/flutter/widgets/Opacity-class.html#performance-considerations-for-opacity-animation
[`RenderObject`]: {{site.api}}/flutter/rendering/RenderObject-class.html
